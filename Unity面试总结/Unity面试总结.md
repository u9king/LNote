# Unity面试总结

#### 1.什么是Unity？

Unity是一套具有完善体系与编辑器的跨平台游戏开发工具，也可称作为游戏引擎。游戏引擎是指一些编写好的可重复利用的利用的代码与开发游戏所用的各功能编辑器。

#### 2.什么是面向对象呢？

面向对象是一种将面向对象的思想应用于软件开发过程并指导开发活动的系统方法。这是一种基于“对象”概念的方法论。对象是由数据和允许的操作组成的包，它与目标实体有直接的对应关系。对象类定义了一组具有类似属性的对象。类的继承是共享具有层次关系的类的属性和操作的一种方式。面向对象是基于对象的概念，以对象为中心，以类和继承为构建机制，认识、理解和描绘客观世界，设计和构建相应的软件系统。

#### 3.都用过Unity哪些模块？

用过**游戏对象和组件系统、图形和渲染、物理引擎、动画系统、用户界面、音频系统、脚本编程、网络功能、优化和性能调优、插件和资产商店**这些模块。

追问**脚本编程（Scripting）**：强调你的编程技能，包括使用C#或Unity的自定义脚本来实现游戏逻辑和互动。

追问**图形和渲染（Graphics and Rendering）**：你可以谈论你对Unity的渲染管线的了解，以及如何使用材质、着色器和光照来创建视觉效果。

#### 4.如何查看游戏性能？

可以通过**帧率监视、性能窗口、Profiler工具、GPU调试来查看。**

a.帧率监视（Frame Rate Monitoring）：

- Unity提供了一个内置的帧率计数器。在Hierarchy视图中创建一个空GameObject，然后将其Inspector视图中的Script组件中的代码附加到该对象，以监视每秒帧数（FPS）。

b.性能窗口（Performance Window）：

- 性能窗口提供了有关CPU、GPU、内存和其他性能方面的详细信息，可以用来识别性能瓶颈和问题。在Unity的顶部菜单栏中，选择"Window" > "Analysis" > "Performance"以打开性能窗口。

c.Profiler工具（Profiler Tool）：

- Unity的Profiler是一个强大的工具，用于深入分析游戏性能。Profiler可以帮助你跟踪函数调用、内存使用、GPU渲染和其他性能相关的信息。你可以通过点击顶部菜单栏的"Window" > "Analysis" > "Profiler"来打开Profiler。

#### 5.面向对象三大特征

a.封装 ：将功能封装成一个个独立的单元，减小耦合，避免牵一发而动全身，方便对程序的修改。

b.继承：代码重用，减少编码量，间接减少维护成本。

c.多态：不同的场合做出不同相应。

#### 6.NGUI/UGUI渲染顺序

Camera 模式下渲染顺序：基于同 Layer 同 OrderInLayer，因为渲染顺序优先 级是：**camera 的 depth 值越大越后渲染>Layer>OrderInLayer>Z 轴**，注意 UI 的渲染顺序最后是OrderInLayer>transform 的层级

#### 7.UGUI消息传递机制

UGUI消息传递机制包括事件系统（Event System）、事件触发器（Event Trigger）和事件监听器（Event Listener）。事件系统捕获用户输入事件，事件触发器定义事件触发条件，而事件监听器用于在事件发生时执行自定义操作。这一机制可用于实现用户界面元素之间的交互和事件处理。

#### 8.UGUI的性能优化

a. **合并UI元素**：将多个UI元素合并到一个Canvas中，以减少批处理次数，特别是在Canvas排序层级相同时。
b. **使用UI对象池**：通过对象池重用UI元素，减少创建和销毁操作，降低内存开销。
c. **限制UI元素数量**：避免在屏幕上过多放置UI元素，尤其是复杂的UI元素。
d. **使用静态Batches**：尽量减少UI元素的动态批处理，使用静态批处理来提高性能。
e. **优化UI材质和纹理**：减少使用材质和纹理的数量，合并UI元素共享的材质，以减少GPU开销。

#### 9.Unity的协程

协程，即为协同程序. Unity中的协程由协程函数和协程调度器两部分构成。协程函数使用的是C#的迭代器, 协程调度器则利用了MonoBehaviour中的生命周期函数来实现. 协程函数实现了分步, 协程调度器实现了分时。

#### 10.Unity3D如何实现跨平台的？

Unity3D的跨平台原理是通过提供统一的开发环境和工具、抽象化的底层接口、平台适配和优化，以及导出和发布功能来实现的。

基于以下几个核心技术和机制：

a.Unity Runtime（运行时）：Unity的核心运行时引擎是一个跨平台的执行环境，它以C++编写并针对不同平台进行了优化。Unity Runtime提供了统一的接口和功能，使得开发者可以在不同平台上编写和运行相同的代码。
b.虚拟机和中间语言：Unity使用了Mono虚拟机作为其脚本运行时，而C#则作为主要的脚本语言。C#代码在Unity中被编译为中间语言（Intermediate Language，IL），然后在不同平台上的Mono虚拟机中运行。这种架构使得C#脚本可以在不同平台上进行交叉编译和执行。
c.跨平台API和封装层：Unity提供了统一的API和封装层，用于访问底层平台的功能和设备接口。这些API和封装层隐藏了不同平台的差异性，使开发者能够以统一的方式访问各种平台的功能，如图形渲染、输入处理、音频播放等。
d.图形渲染抽象和底层图形API：Unity使用了抽象的图形渲染接口来实现跨平台的图形渲染。它将高级的图形指令转换为底层图形API（如OpenGL、DirectX、Metal等）所需的指令，并根据目标平台动态选择和调用适当的图形API。
e.平台相关优化和适配：Unity针对不同平台进行了优化和适配，以提供最佳的性能和用户体验。它根据目标平台的特性和限制进行相应的优化，如图形质量调整、内存管理、设备适配等，以确保游戏在各个平台上运行流畅并具有良好的表现。













#### 知识点

1.VR设备中的陀螺仪

2.MR中的混合现实技术

3.UV展开

4.着色器，材质球





#### 待解决问题

1. 都用过Unity哪些模块？
2. 如何查看游戏性能
3. NGUI UGUI渲染顺序
4. UGUI消息传递机制
5. UGUI的优化
6. Unity的协程
7. Unity协程怎么用， 协程的源码怎么写的？
8. Unity3D如何实现跨平台的
9. Unity的GC原理
10. Unity协程底层实现
11. Unity碰撞检测原理
12. Unity模型资源，模型动画
13. 动画状态机驱动的是什么
14. Unity如何改变一个物体的位置旋转？
15. Unity本地坐标和世界坐标
16. Unity调整旋转需要传什么参数
17. Unity3d的生命周期
18. unity脚本生命周期
19. Unity 脚本函数生命周期
20. UI渲染顺序
21. 如何在UI上显示模型
22. UI上粒子效果如何实现
23. Unity函数运行顺序
24. Update()和 FixedUpdate() 的区别
25. unity的垃圾回收
26. 预设(prefab)的好处
27. 碰撞体和触发器区别与联系
28. Unity协程

**图形学**

在面试的时候会图形学会很加分。**面试题**

1. 渲染管线 （必问）

2. 什么是depth buffer

3. 提前深度测试

4. phong和billin-phong

5. 正向渲染和延迟渲染的区别

6. 透明物体和不透明物体渲染顺序

7. 如何优化shader

8. shader中的if会造成性能影响以及优化

9. 线性空间和srgb空间是怎么反映的

10. gamma correction是怎么实现的

11. 顶点着色器实现光照会怎么样

12. 顶点着色器作用，包括什么工作

13. 顶点着色器到片元着色器中间流程

14. 几何着色器的作用，顶点着色器传输给几何着色器什么数据

15. EBO存储的数据是什么，有什么好处

16. G-Buffer的底层结构

17. Drawcall 原理以及如何减少DrawCall

18. 光栅化的作用？

19. 光栅化过程中常用的算法

20. 实时阴影如何实现、生成

21. shadowmap实现原理

22. 屏幕空间的阴影算法原理

23. PBR的理解

24. 哪些描边的技术以及有啥优缺点

25. 色调映射，HDR与LDR的区别

26. 为什么延迟渲染对MSAA支持不好

27. BRDF与兰伯特模型的联系是什么

28. 球谐光照的理解

29. 对伽马校正的理解

30. 屏幕空间阴影映射技术的优点

31. 卡通渲染思路

32. 如何渲染半透明物体

33. 为什么要用FrameBuffer

34. 纹理坐标？双线性插值怎么做的

35. mipmap有什么缺点

36. LOD怎么做的

37. Bloom怎么做的

38. 伽马矫正

39. 动态模糊怎么做的

40. opengl与openglES

**数学相关**

1. MVP矩阵空间变换过程

2. M矩阵中旋转、平移、缩放顺序，分别在M矩阵的哪个部分

3. 四元数的理解，如何从两个向量判断四元数（四个参数的代表内容）

4. 变换矩阵里每一列代表什么

5. 为什么MVP矩阵是 4*4

6. 点乘叉乘几何意义，用处

7. 点到平面的距离如何计算

8. 几何阶段的矩阵变换都有哪些

9. 如何判断一个点是否在一个凸多边形内

10. 旋转有哪几种方式？欧拉角会有什么问题？讲一下四元数

11. 为什么使用齐次坐标

12. AABB包围盒如何判断相交与分离

    1. 摄像机跟随怎么做的

    2. 如何做攻击判定

    3. 游戏中怎么实时生成的地图

    4. 热更新与加载怎么实现

    5. 客户端如何优化效率

    6. 客户端怎么判断掉线

    7. 断线重连怎么做的

    8. 帧同步和状态同步的比较

    9. 帧同步，状态同步，分别怎么应对恶劣网络环境

    10. 帧同步定点数改造什么方案

    11. 卡帧怎么处理

    12. 帧同步的碰撞检测和碰撞效果

    13. 帧同步容器遍历问题

    14. 帧同步出现不同步，怎么查的

    15. 吃鸡和moba在技术上的区别

    16. A* 算法介绍

    17. 碰撞检测的方法

    18. 游戏里的排行榜系统怎么设计

    19. FPS游戏里子弹模型怎么设计

    20. 如何判断敌人在射程范围之内？

    1. C和 C++ 的区别

    2. struct与class的区别

    3. new/delete与malloc/free的区别

    4. 指针与引用的区别

    5. 深拷贝与浅拷贝的区别

    6. 移动构造函数与拷贝构造函数区别

    7. 重写与重载区别

    8. 内联函数与宏定义区别

    9. 数组和指针区别

    10. 前置++与后置++的区别

    11. 动态链接库和静态链接库的区别

    12. 关键字：static、const、extern、volatile作用

    13. 源文件从文本到可执行文件经历的过程

    14. 四种类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast